type ecs_Attachment {
  details: [ecs_KeyValuePair]
  attachmentId: ID
  status: String
  type: String
}

type ecs_Attribute {
  name: String
  targetId: ID
  targetType: String
  value: String
}

type ecs_AwsVpcConfiguration {
  assignPublicIP: String
  securityGroups: [String]
  subnets: [String]
}

type ecs_CapacityProviderStrategyItem {
  base: Int
  capacityProvider: String
  weight: Int
}

type ecs_Cluster @model(key: ["clusterArn"]) {
  activeServicesCount: Int
  attachments: [ecs_Attachment]
  attachmentsStatus: String
  capacityProviders: [String]
  clusterArn: ID
  clusterName: String
  defaultCapacityProviderStrategy: [ecs_CapacityProviderStrategyItem]
  pendingTasksCount: Int
  registeredContainerInstancesCount: Int
  runningTasksCount: Int
  settings: [ecs_ClusterSetting]
  statistics: [ecs_KeyValuePair]
  status: String
  tags: [ecs_Tag]
}

type ecs_ClusterSetting {
  name: String
  value: String
}

type ecs_ContainerDefinition {
  command: [String]
  cpu: Int
  dependsOn: [ecs_ContainerDependency]
  disableNetworking: Boolean
  dnsSearchDomains: [String]
  dnsServers: [String]
  dockerLabels: [ecs_DockerLabelsMapItem]
  dockerSecurityOptions: [String]
  entryPoint: [String]
  environment: [ecs_KeyValuePair]
  environmentFiles: [ecs_EnvironmentFile]
  essential: Boolean
  extraHosts: [ecs_HostEntry]
  firelensConfiguration: ecs_FirelensConfiguration
  healthCheck: ecs_HealthCheck
  hostname: String
  image: String
  interactive: Boolean
  links: [String]
  linuxParameters: ecs_LinuxParameters
  logConfiguration: ecs_LogConfiguration
  memory: Int
  memoryReservation: Int
  mountPoints: [ecs_MountPoint]
  name: String
  portMappings: [ecs_PortMapping]
  privileged: Boolean
  pseudoTerminal: Boolean
  readonlyRootFilesystem: Boolean
  repositoryCredentials: ecs_RepositoryCredentials
  resourceRequirements: [ecs_ResourceRequirement]
  secrets: [ecs_Secret]
  startTimestampout: Int
  stopTimestampout: Int
  systemControls: [ecs_SystemControl]
  ulimits: [ecs_Ulimit]
  user: String
  volumesFrom: [ecs_VolumeFrom]
  workingDirectory: String
}

type ecs_ContainerDependency {
  condition: String
  containerName: String
}

type ecs_DeploymentConfiguration {
  maximumPercent: Int
  minimumHealthyPercent: Int
}

type ecs_DeploymentController {
  type: String
}

type ecs_Device {
  containerPath: String
  hostPath: String
  permissions: [String]
}

type ecs_DockerLabelsMapItem {
  key: String
  value: String
}

type ecs_DockerVolumeConfiguration {
  autoprovision: Boolean
  driver: String
  driverOpts: [ecs_StringMapItem]
  labels: [ecs_StringMapItem]
  scope: String
}

type ecs_EFSAuthorizationConfig {
  accessPointId: ID
  iam: String
}

type ecs_EFSVolumeConfiguration {
  authorizationConfig: ecs_EFSAuthorizationConfig
  fileSystemId: ID
  rootDirectory: String
  transitEncryption: String
  transitEncryptionPort: Int
}

type ecs_EnvironmentFile {
  type: String
  value: String
}

type ecs_FirelensConfiguration {
  options: [ecs_FirelensConfigurationOptionsMapItem]
  type: String
}

type ecs_FirelensConfigurationOptionsMapItem {
  key: String
  value: String
}

type ecs_HealthCheck {
  command: [String]
  interval: Int
  retries: Int
  startPeriod: Int
  timeout: Int
}

type ecs_HostEntry {
  hostname: String
  ipAddress: String
}

type ecs_HostVolumeProperties {
  sourcePath: String
}

type ecs_InferenceAccelerator {
  deviceName: String
  deviceType: String
}

type ecs_KernelCapabilities {
  add: [String]
  drop: [String]
}

type ecs_KeyValuePair {
  name: String
  value: String
}

type ecs_LinuxParameters {
  capabilities: ecs_KernelCapabilities
  devices: [ecs_Device]
  initProcessEnabled: Boolean
  maxSwap: Int
  sharedMemorySize: Int
  swappiness: Int
  tmpfs: [ecs_Tmpfs]
}

type ecs_LoadBalancer {
  containerName: String
  containerPort: Int
  loadBalancerName: String
  targetGroupArn: String
}

type ecs_LogConfiguration {
  logDriver: String
  options: [ecs_LogConfigurationOptionsMapItem]
  secretOptions: [ecs_Secret]
}

type ecs_LogConfigurationOptionsMapItem {
  key: String
  value: String
}

type ecs_MountPoint {
  containerPath: String
  readOnly: Boolean
  sourceVolume: String
}

type ecs_NetworkConfiguration {
  awsVpcConfiguration: ecs_AwsVpcConfiguration
}

type ecs_PlacementConstraint {
  expression: String
  type: String
}

type ecs_PlacementStrategy {
  field: String
  type: String
}

type ecs_PortMapping {
  containerPort: Int
  hostPort: Int
  protocol: String
}

type ecs_ProxyConfiguration {
  containerName: String
  properties: [ecs_KeyValuePair]
  type: String
}

type ecs_RepositoryCredentials {
  credentialsParameter: String
}

type ecs_ResourceRequirement {
  type: String
  value: String
}

type ecs_Scale {
  unit: String
  value: Float
}

type ecs_Secret {
  name: String
  valueFrom: String
}

type ecs_Service @model(key: ["serviceArn"]) {
  capacityProviderStrategy: [ecs_CapacityProviderStrategyItem]
  cluster: ecs_Cluster @reference(back: "services")
  clusterArn: String
  createdAt: Timestamp
  createdBy: String
  deploymentConfiguration: ecs_DeploymentConfiguration
  deploymentController: ecs_DeploymentController
  desiredCount: Int
  enableECSManagedTags: Boolean
  events: [ecs_ServiceEvent]
  healthCheckGracePeriodSeconds: Int
  launchType: String
  loadBalancers: [ecs_LoadBalancer]
  networkConfiguration: ecs_NetworkConfiguration
  pendingCount: Int
  placementConstraints: [ecs_PlacementConstraint]
  placementStrategy: [ecs_PlacementStrategy]
  platformVersion: String
  propagateTags: String
  roleArn: String
  runningCount: Int
  schedulingStrategy: String
  serviceArn: ID
  serviceName: String
  serviceRegistries: [ecs_ServiceRegistry]
  status: String
  tags: [ecs_Tag]
  taskDefinition: ecs_TaskDefinition @reference(back: "services")
  taskSets: [ecs_TaskSet]
}

type ecs_ServiceEvent {
  createdAt: Timestamp
  serviceEventId: ID
  message: String
}

type ecs_ServiceRegistry {
  containerName: String
  containerPort: Int
  port: Int
  registryArn: String
}

type ecs_StringMapItem {
  key: String
  value: String
}

type ecs_SystemControl {
  namespace: String
  value: String
}

type ecs_Tag {
  key: String
  value: String
}

type ecs_TaskDefinition @model(key: ["taskDefinitionArn"]){
  compatibilities: [String]
  containerDefinitions: [ecs_ContainerDefinition]
  cpu: String
  executionRoleArn: String
  family: String
  inferenceAccelerators: [ecs_InferenceAccelerator]
  ipcMode: String
  memory: String
  networkMode: String
  pidMode: String
  placementConstraints: [ecs_TaskDefinitionPlacementConstraint]
  proxyConfiguration: ecs_ProxyConfiguration
  requiresAttributes: [ecs_Attribute]
  requiresCompatibilities: [String]
  revision: Int
  status: String
  taskDefinitionArn: ID
  taskRoleArn: String
  volumes: [ecs_Volume]
}

type ecs_TaskDefinitionPlacementConstraint {
  expression: String
  type: String
}

type ecs_TaskSet {
  capacityProviderStrategy: [ecs_CapacityProviderStrategyItem]
  clusterArn: String
  computedDesiredCount: Int
  createdAt: Timestamp
  externalId: ID
  taskSetId: ID
  launchType: String
  loadBalancers: [ecs_LoadBalancer]
  networkConfiguration: ecs_NetworkConfiguration
  pendingCount: Int
  platformVersion: String
  runningCount: Int
  scale: ecs_Scale
  serviceArn: String
  serviceRegistries: [ecs_ServiceRegistry]
  stabilityStatus: String
  stabilityStatusAt: Timestamp
  startedBy: String
  status: String
  tags: [ecs_Tag]
  taskDefinition: String
  taskSetArn: String
  updatedAt: Timestamp
}

type ecs_Tmpfs {
  containerPath: String
  mountOptions: [String]
  size: Int
}

type ecs_Ulimit {
  hardLimit: Int
  name: String
  softLimit: Int
}

type ecs_Volume {
  dockerVolumeConfiguration: ecs_DockerVolumeConfiguration
  efsVolumeConfiguration: ecs_EFSVolumeConfiguration
  host: ecs_HostVolumeProperties
  name: String
}

type ecs_VolumeFrom {
  readOnly: Boolean
  sourceContainer: String
}

type ecs_Deployment @model(key: ["deploymentId"]) {
  capacityProviderStrategy: [ecs_CapacityProviderStrategyItem]
  createdAt: Timestamp
  desiredCount: Int
  deploymentId: ID
  launchType: String
  networkConfiguration: ecs_NetworkConfiguration
  pendingCount: Int
  platformVersion: String
  runningCount: Int
  service: ecs_Service @reference(back: "deployments")
  status: String
  taskDefinition: String
  updatedAt: Timestamp
}
